<html><head><title>Community Vote Analysis</title>
     <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    
    <style>
// from https://loading.io/css/
lds-ellipsis {
  display: inline-block;
  position: relative;
  width: 64px;
  height: 64px;
}
.lds-ellipsis div {
  position: absolute;
  top: 27px;
  width: 11px;
  height: 11px;
  border-radius: 50%;
  background: #cef;
  animation-timing-function: cubic-bezier(0, 1, 1, 0);
}
.lds-ellipsis div:nth-child(1) {
  left: 6px;
  animation: lds-ellipsis1 0.6s infinite;
}
.lds-ellipsis div:nth-child(2) {
  left: 6px;
  animation: lds-ellipsis2 0.6s infinite;
}
.lds-ellipsis div:nth-child(3) {
  left: 26px;
  animation: lds-ellipsis2 0.6s infinite;
}
.lds-ellipsis div:nth-child(4) {
  left: 45px;
  animation: lds-ellipsis3 0.6s infinite;
}
@keyframes lds-ellipsis1 {
  0% {
    transform: scale(0);
  }
  100% {
    transform: scale(1);
  }
}
@keyframes lds-ellipsis3 {
  0% {
    transform: scale(1);
  }
  100% {
    transform: scale(0);
  }
}
@keyframes lds-ellipsis2 {
  0% {
    transform: translate(0, 0);
  }
  100% {
    transform: translate(19px, 0);
  }
}
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    
    <script src="https://unpkg.com/dsteem@latest/dist/dsteem.js"></script>
<script>
    
  const client = new dsteem.Client('https://api.steemit.com');
    
  const reverseAuctionTimeMin = 15;
    
  let lastStart = -1;
  let account = '';
  let votedUser = '';
    
  let numPosts = 0;
  let totalPayout = 0;
  let totalCuration = 0;
  let sumVoteTime = 0;
  let sumWeightedOptVoteTime = 0;
  let sumWeights = 0;

  function getAmount(v) {
      return Number(v.split(' ')[0]);
  }
    
  function getDelegations(account, callback) {
      doGetDelegations(account, -1, [], callback);
  }
    
  function doGetDelegations(account, start, delegationTransactions, callback) {
      console.log(`Fetching account history for ${account} at ${start}`);
      client.database.call('get_account_history', [account, start, (start < 0) ? 10000 : Math.min(start, 10000)]).then((result) => {
          result.reverse();
          let lastTrans = start;
          
          result.forEach(function(trans) {
              var op = trans[1].op;

              if(op[0] == 'delegate_vesting_shares' && op[1].delegatee == account) {
                  delegationTransactions.push({ id: trans[0], data: op[1] });
              }
              
              // Save the ID of the last transaction that was processed.
              lastTrans = trans[0];
          });

          if(lastTrans > 0 && lastTrans != start) {
              return doGetDelegations(account, lastTrans, delegationTransactions, callback);
          } else {
              if (lastTrans > 0) {
                  console.log('Missing account history.... last trans: ' + lastTrans);
              }
          }
          return callback(processDelegations(delegationTransactions));
      }, (err) => {
          console.log(err);
      });
  }
    
  function processDelegations(delegationTransactions) {
      const delegations = {};

      // Go through the delegation transactions from oldest to newest to find the final delegated amount from each account
      delegationTransactions.reverse();

      for(var i = 0; i < delegationTransactions.length; i++) {
          var trans = delegationTransactions[i];

          // Check if this is a new delegation or an update to an existing delegation from this account
          var delegation = delegations[trans.data.delegator];

          if (delegation) {
              if (parseFloat(trans.data.vesting_shares) > 0) {
                  delegation.vesting_shares = trans.data.vesting_shares;
              } else {
                  delegations[trans.data.delegator] = null;
              }
          } else if (parseFloat(trans.data.vesting_shares) > 0) {
              delegations[trans.data.delegator] = { delegator: trans.data.delegator, vesting_shares: trans.data.vesting_shares };
          }
      }
      
      // Return a list of all delegations (and filter out any that are 0)
      return delegations;
  }

  function appendAnalysis(info) {
      /**
      {
        created: post.created,
        author: post.author,
        permlink: post.permlink,
        optVoteTimeMin: optVote.voteAgeMillis / 60000,
        optVoteCuration: optVote.voterCuration,
        accountVoteTimeMin: accountVoteTimeMillis / 60000,
        accountVoterCuration,
        optRatio,
        delegatedVests,
      }
      */
      color = '#ffffff';
      if (info.optRatio > 2) {
          color = '#ffffdd';
      }
      if (info.optRatio > 5) {
          color = '#ffeedd';
      }
      if (info.optRatio > 10) {
          color = '#ffdddd';
      }
      $('#data-table tr:last').after('<tr style="background-color: ' + color + ';"><td>' + info.author + '</td><td>' + info.numPosts + '</td><td>' + info.voteValue + '</td><td>' + info.delegatedVests + '</td><td>' + info.ratio + '</td></tr>');
  }
    
  function loadCurations(account, start, votedUser, callback) {
    return getCurations(account, start, votedUser, callback);
  }

  function getCurations(account, start, votedUser, callback) {
    let lastTrans = start;
  
    getDelegations(account, delegations => {
        console.log(delegations);
        console.log(`Fetching account history for ${account} at ${start}`);
        $('#loading').toggle(true);
        client.database.call('get_account_history', [account, start, (start < 0) ? 10000 : Math.min(start, 10000)]).then((result) => {
          let hasError = false;
          const postFetchPromises = [];
          const voteSummaries = {};
          if (!hasError) {
            result.reverse();

            result.forEach(function(trans) {
              var op = trans[1].op;

              if (op[0] == 'curation_reward') {
                  const curationReward = op[1];

                  if (Date.parse(Date()) - Date.parse(trans[1].timestamp) <= 7*24*60*60*1000 && (!votedUser || curationReward.comment_author === votedUser)) {
                  postFetchPromises.push(client.database.call('get_content', [curationReward.comment_author, curationReward.comment_permlink]).then(post => {
                      if (post.parent_author === '') {

                      const createdTime = post.created;
                      const totalSbd = getAmount(post.total_payout_value) + 
                            getAmount(post.curator_payout_value);

                          
                      const votes = post.active_votes.filter(v => v.rshares > 0);

                      const totalRshares = votes.reduce((amt, v) => amt + parseInt(v.rshares), 0);

                      const accountVote = votes.find(v => v.voter === account);
                      
                      const voteRshares = parseInt(accountVote.rshares);
                      const voteValue = voteRshares * totalSbd / totalRshares;

                      const delegatedVests = delegations[post.author] ? delegations[post.author].vesting_shares : "";

                      const voteSummary = voteSummaries[post.author];
                      if (!voteSummary) {
                          voteSummaries[post.author] = {
                              author: post.author,
                              numPosts: 1,
                              totalVoteValue: voteValue,
                              delegatedVests,
                              ratio: 10000 * voteValue / parseFloat(delegatedVests)
                          };
                      } else {
                          voteSummary.numPosts++;
                          voteSummary.totalVoteValue += voteValue;
                          voteSummary.ratio = 10000 * voteSummary.totalVoteValue / parseFloat(voteSummary.delegatedVests);
                      }

                      numPosts++;
                      totalPayout += totalSbd;
                  }
                  }, error => {
                      console.log(`Error fetching ${curationReward.comment_permlink}. Normal if post was deleted.`);
                      console.log(error);
                  })); 
                  }
              }
              // Save the ID of the last transaction that was processed.
              lastTrans = trans[0];
            });

            if(lastTrans > 0 && lastTrans != start) {
            } else {
              if (lastTrans > 0) {
                console.log('Missing account history.... last trans: ' + lastTrans);
                hasError = true;
              }
            }
          }

          if (hasError) {
            // add indication that loading failed
            $('#error').html('Error while loading.');
          }
          Promise.all(postFetchPromises).then(result => {
            callback(lastTrans, voteSummaries);
          });
        }, (err) => {
            // add indication that loading failed
            $('#error').html('Error while loading.');
        }); 
    });
  }
    
  function adjustSummary() {
      let summary = '';
      const avgPayout = totalPayout / numPosts;
      const avgVoteTime = (sumVoteTime / numPosts) / 60000;
      const recVoteTime = (sumWeightedOptVoteTime / sumWeights) / 60000;
      summary += '<table class="table"><tbody>';
      summary += '<tr><td>Number of Posts:</td><td>' + numPosts + '</td></tr>';
      summary += '<tr><td>Total Post Payout:</td><td>' + totalPayout + ' STU</td></tr>';
      summary += '<tr><td>Average Post Payout:</td><td>' + avgPayout + ' STU</td></tr>';
      summary += '<tr><td>Curation Earned:</td><td>' + totalCuration + 'STU</td></tr>';
      summary += '<tr><td>Current Avg Upvote Time:</td><td>' + avgVoteTime + ' minutes. </td></tr>';
      summary += '<tr><td>Optimized Upvote Time Recommendation:</td><td>' + recVoteTime + ' minutes. </td></tr>';
      $('#summary').html(summary);
  }
  
  function loadAll(account, start, votedUser) {
    loadCurations(account, start, votedUser, (lastTrans, voteSummaries) => {
      $('#loading').toggle(false);
        

      Object.keys(voteSummaries).sort((a,b) => {
          const avv = voteSummaries[a].totalVoteValue ? parseFloat(voteSummaries[a].totalVoteValue) : 0;
          const bvv = voteSummaries[b].totalVoteValue ? parseFloat(voteSummaries[b].totalVoteValue) : 0;
          return bvv - avv;
      }).forEach(author => {
          const voteSummary = voteSummaries[author];
                      appendAnalysis({
                          author: voteSummary.author,
                          numPosts: voteSummary.numPosts,
                          voteValue: voteSummary.totalVoteValue,
                          delegatedVests: voteSummary.delegatedVests,
                          ratio: voteSummary.ratio
                      })
      });;

        
      adjustSummary();
      lastStart = lastTrans;
    });
  }

  $(function() {
    //https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/21152762#21152762
    var qd = {};
    if (location.search)
      location.search.substr(1).split("&").forEach(function(item) {
        var s = item.split("="),
          k = s[0],
          v = s[1] && decodeURIComponent(s[1]); //  null-coalescing / short-circuit
       //(k in qd) ? qd[k].push(v) : qd[k] = [v]
       (qd[k] = qd[k] || []).push(v) // null-coalescing / short-circuit
    })
    if (qd.account && qd.account[0] != "") {
      account = qd.account[0];
      votedUser = qd.votedUser && qd.votedUser[0] != "" ? qd.votedUser[0] : '';
      $('#params input[name="account"').val(account);
      $('#params input[name="votedUser"').val(votedUser);  
      loadAll(account, lastStart, votedUser);
    }
  });
</script>
</head>
  <body>
    <div class="container">
      <div class="jumbotron">
          <h2>Community Vote Analysis</h2>
          <p> Problems? Suggestions? File issues <a href="https://github.com/helpienaut/helpienaut.github.io/issues">here!</a></p>
      
          <p>Compares votes issued by community vs delegation. Looks at last 7 days.</p>
      </div>
      <form method="get" id="params">
          <div class="form-group">
              <label for="account">Voter</label> 
              <input type="text" class="form-control col-sm-3" name="account" id="account" />
          </div>
          <div class="form-group">
              <label for="votedUser">Recipient</label>
              <input type="text" class="form-control col-sm-3" name="votedUser" id="votedUser" />
          </div>
          <input class="btn btn-primary" type="submit" value="Analyze" />
      </form>
      <hr />
      <table id="data-table" class="table table-striped">
          <tbody><tr><td>Author</td><td>Num Posts</td><td>Total Vote Value</td><td>Delegated Vests</td><td>Ratio</td></tr>
          </tbody></table>
      <div id="error"></div>
      <div id="loading" style="position: relative; display: none">
      <div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
      </div>
      <hr>
      <h1>Summary</h1>
      <div id="summary"></div>
      </div>
    </body>
</html>
